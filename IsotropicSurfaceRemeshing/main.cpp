// most of the coment are generated by IA, it is fast and clear.

#include <iostream>
#include <cstdio>
#include <chrono>

#include <vector>
#include <Eigen/Dense>
#include <random>
#include <cstdlib>  // Pour rand() et srand()
#include <ctime>    // Pour time()
#include <cmath>
#include <algorithm>
#include <queue>
#include <unordered_set>
#include <unordered_map>

// external library
#include "delaunator.hpp"

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Delaunay_triangulation_adaptation_traits_2.h>
#include <CGAL/Delaunay_triangulation_adaptation_policies_2.h>
#include <CGAL/Voronoi_diagram_2.h>

#include <igl/boundary_loop.h>
#include <igl/harmonic.h>
#include <igl/map_vertices_to_circle.h>
#include <igl/read_triangle_mesh.h>
#include <igl/opengl/glfw/Viewer.h>



#ifndef M_PI
#define M_PI 3.14159265358979323846  
#endif

// Définition des types CGAL
typedef CGAL::Exact_predicates_inexact_constructions_kernel                  K;
typedef CGAL::Delaunay_triangulation_2<K>                                    DT;
typedef CGAL::Delaunay_triangulation_adaptation_traits_2<DT>                 AT;
typedef CGAL::Delaunay_triangulation_caching_degeneracy_removal_policy_2<DT> AP;
typedef CGAL::Voronoi_diagram_2<DT,AT,AP>                                    VD;
typedef DT::Point Point;

typedef AT::Site_2                    Site_2;
typedef AT::Point_2                   Point_2;

typedef VD::Locate_result             Locate_result;
typedef VD::Vertex_handle             Vertex_handle;
typedef VD::Face_handle               Face_handle;
typedef VD::Halfedge_handle           Halfedge_handle;
typedef VD::Ccb_halfedge_circulator   Ccb_halfedge_circulator;

typedef Eigen::MatrixXd MatrixXd;
typedef Eigen::MatrixXi MatrixXi;


MatrixXd V_new_original;  // The result mesh (not computed)
MatrixXd V0, V1;    // the camel and monkey vertices
MatrixXi F0, F1;    // the camel and monkey triangles
MatrixXd V_uv, V_new_uv;    // the vertices in parameter space
MatrixXi F_new, F_new_;     // delaunay triangles
MatrixXd P;     // vertices of Voronoi tessellation
MatrixXi Fp;    // edges of Voronoi tessellation
MatrixXd bnd_uv;    // boundaries of the mesh in parameter space
Eigen::VectorXi corners;    // set of corners vertices 
MatrixXi featureEdges;      // set of feature edges

std::vector<std::pair<int, int>>  FacesPath, FeaturePath;   // spanning tree (path for error propagatino

double SRs;      // sample rate of surfaces
double SRf;      // sample rate of features

std::vector<float> FaceDensity, featureEdgeDensity;     // density on triangles and on feature Edges
std::vector<int> nbNewVerticesInTriangles, nbNewVerticesInFeatureEges;  // local budge of vertices for triangles and for feature Edges


struct Edge_ {
    int v0, v1;
    bool operator==(const Edge_& other) const {
        return (v0 == other.v0 && v1 == other.v1) || (v0 == other.v1 && v1 == other.v0);
    }
};

// Structure representing an edge of a triangle (with a as the index of the first vertex and b as the index of the second)
struct Edge {
    unsigned int a , b;
    Edge( unsigned int c , unsigned int d ) : a( std::min<unsigned int>(c,d) ) , b( std::max<unsigned int>(c,d) ) {}
    bool operator < ( Edge const & o ) const {   return a < o.a  ||  (a == o.a && b < o.b);  }
    bool operator == ( Edge const & o ) const {   return a == o.a  &&  b == o.b;  }
};

struct Triangle {
    int v0, v1, v2;
};

int randomInt(int x) {
    std::random_device rd; 
    std::mt19937 gen(rd()); 
    std::uniform_int_distribution<int> dist(0, x); // Range [0, x]

    return dist(gen);
}


// to calculate the area of a triangle 3D
double triangleArea(const Eigen::RowVector3d &A, const Eigen::RowVector3d &B, const Eigen::RowVector3d &C) {
    return 0.5 * ((B - A).cross(C - A)).norm();
}

// to calculate the area of a triangle 2D
double triangleArea2D(const Eigen::RowVector2d &A, const Eigen::RowVector2d &B, const Eigen::RowVector2d &C) {
    return 0.5 * std::abs((B - A).x() * (C - A).y() - (B - A).y() * (C - A).x());
}



int isInFeat(const MatrixXi &feat, const Edge &edge) {  // return -1 if not in feat, else return the index in feat of this edge  
    for (int i = 0; i < feat.rows(); ++i) {
        if ((feat(i, 0) == edge.a && feat(i, 1) == edge.b) ||
            (feat(i, 0) == edge.b && feat(i, 1) == edge.a)) { // non oriented edge
            return i;
        }
    }
    return -1;
}





void arbreCouvrant(
        std::vector<std::pair<int, int>> &FacesP,    // First index: parent triangle, second: child triangle
        std::vector<std::pair<int, int>> &FeaturesP,  // First index: parent feature edge, second: child feature edge
        const MatrixXi &F,                           // Matrix of triangles (faces) with vertex indices
        const MatrixXi &feat,                        // Matrix of feature edges with vertex indices
        const std::map<unsigned int, std::set<unsigned int>> &adjacentVertices,  // Map of vertices and their adjacent vertices
        const std::map<Edge, std::set<unsigned int>> &trianglesOnEdge) {         // Map of edges and their associated triangles

    std::cout << "in arbreCouvrant" << std::endl;

    // ------- Spanning Tree for Triangles (BFS) -------
    std::unordered_set<int> visitedTriangles;  // Set to track visited triangles
    std::queue<int> queueTriangles;            // Queue for BFS traversal of triangles

    // Choose a random starting triangle for the spanning tree of triangles
    int randomTriangleIndex = randomInt(F.rows());

    // Start with this triangle
    queueTriangles.push(randomTriangleIndex);
    visitedTriangles.insert(randomTriangleIndex);

    while (!queueTriangles.empty()) {
        int current = queueTriangles.front();
        queueTriangles.pop();

        // Explore the neighbors of the current triangle using shared edges
        for (int i = 0; i < 3; ++i) {
            int v1 = F(current, i);
            int v2 = F(current, (i + 1) % 3);
            Edge edge(v1, v2);

            // Check if the edge is shared with another triangle
            auto it = trianglesOnEdge.find(edge);
            if (it != trianglesOnEdge.end()) {
                for (int neighbor : it->second) {
                    // If the neighbor triangle hasn't been visited, add it to the tree
                    if (visitedTriangles.find(neighbor) == visitedTriangles.end()) {
                        FacesP.emplace_back(current, neighbor);
                        visitedTriangles.insert(neighbor);
                        queueTriangles.push(neighbor);
                    }
                }
            }
        }
    }

    // ------- Spanning Tree for Feature Edges (BFS) -------
    std::unordered_set<int> visitedFeatures;    // Set to track visited feature edges
    std::queue<int> queueFeatures;              // Queue for BFS traversal of feature edges

    int totalEdges = feat.rows();

    int currentEdgeIndex = -1;
    while (visitedFeatures.size() < totalEdges) {  // Continue until all edges are visited
        int startEdgeIndex = -1;
        
        // Find a new unvisited feature edge
        for (int i = 0; i < totalEdges; ++i) {
            if (visitedFeatures.find(i) == visitedFeatures.end()) {
                startEdgeIndex = i;
                break;
            }
        }

        if (startEdgeIndex == -1) break;  // Should never happen, but safety check

        if (currentEdgeIndex != -1) {  // Link non-convex parts of the feature edges
            FeaturesP.emplace_back(currentEdgeIndex, startEdgeIndex);
        }

        // Start a BFS from the new unvisited feature edge
        queueFeatures.push(startEdgeIndex);
        visitedFeatures.insert(startEdgeIndex);

        while (!queueFeatures.empty()) {
            currentEdgeIndex = queueFeatures.front();
            queueFeatures.pop();

            int start_vertix = feat(currentEdgeIndex, 0);  // First vertex of the feature edge
            int end_vertix = feat(currentEdgeIndex, 1);    // Second vertex of the feature edge

            // Explore neighboring feature edges using the start vertex
            for (int neighbor_start_vertix : adjacentVertices.at(start_vertix)) {
                Edge e(start_vertix, neighbor_start_vertix);
                int childFeatureEdgeIndex = isInFeat(feat, e);
                if (childFeatureEdgeIndex != -1 && visitedFeatures.find(childFeatureEdgeIndex) == visitedFeatures.end()) {
                    FeaturesP.emplace_back(currentEdgeIndex, childFeatureEdgeIndex);
                    visitedFeatures.insert(childFeatureEdgeIndex);
                    queueFeatures.push(childFeatureEdgeIndex);
                }
            }

            // Explore neighboring feature edges using the end vertex
            for (int neighbor_end_vertix : adjacentVertices.at(end_vertix)) {
                Edge e(end_vertix, neighbor_end_vertix);
                int childFeatureEdgeIndex = isInFeat(feat, e);
                if (childFeatureEdgeIndex != -1 && visitedFeatures.find(childFeatureEdgeIndex) == visitedFeatures.end()) {
                    FeaturesP.emplace_back(currentEdgeIndex, childFeatureEdgeIndex);
                    visitedFeatures.insert(childFeatureEdgeIndex);
                    queueFeatures.push(childFeatureEdgeIndex);
                }
            }
        }
    }

    std::cout << "out arbreCouvrant" << std::endl << std::endl;
}


void errorPropagation(
        std::vector<int> &nb_v_in_Tri,          // Vector to store the number of vertices assigned to each triangle
        std::vector<int> &nb_v_in_feat_edge,    // Vector to store the number of vertices assigned to each feature edge
        const double &Rs,                       // Scaling factor for triangles
        const double &Rf,                       // Scaling factor for feature edges
        const std::vector<float> &faceDens,     // Vector of densities for the faces (triangles)
        const std::vector<float> &featEdgeDens, // Vector of densities for the feature edges
        const MatrixXd &V_uv,                   // Matrix of 2D vertex coordinates
        const MatrixXi &F,                      // Matrix of face (triangle) vertex indices
        const MatrixXi &featureEdges,           // Matrix of feature edge vertex indices
        const std::vector<std::pair<int, int>> &FacesP,  // Parent-child pairs for the spanning tree of triangles
        const std::vector<std::pair<int, int>> &FeaturesP) {  // Parent-child pairs for the spanning tree of feature edges

    std::cout << "in errorPropagation" << std::endl;

    int numFaces = faceDens.size();
    int numEdges = featEdgeDens.size();

    // Resize vectors to store the number of vertices for each triangle and feature edge
    nb_v_in_Tri.resize(numFaces, 0);
    nb_v_in_feat_edge.resize(numEdges, 0);

    // Vectors to store the fractional number of vertices for each triangle and feature edge
    std::vector<double> fractionalVertices(numFaces, 0.0f);
    std::vector<double> fractionalEdges(numEdges, 0.0f);

    // Step 1: Assign initial vertex count based on the density for the triangles
    for (int i = 0; i < numFaces; ++i) {
        Eigen::RowVector2d A_uv = V_uv.row(F(i, 0));
        Eigen::RowVector2d B_uv = V_uv.row(F(i, 1));
        Eigen::RowVector2d C_uv = V_uv.row(F(i, 2));
        fractionalVertices[i] = Rs * faceDens[i] * triangleArea2D(A_uv, B_uv, C_uv);
    }

    // Assign initial vertex count based on the density for the feature edges
    for (int i = 0; i < numEdges; ++i) {
        Eigen::RowVector2d A_uv = V_uv.row(featureEdges(i, 0));
        Eigen::RowVector2d B_uv = V_uv.row(featureEdges(i, 1));
        fractionalEdges[i] = Rf * featEdgeDens[i] * (A_uv - B_uv).norm();
    }

    // Step 2: Propagate the error through the spanning tree for the triangles
    int parent;
    int child;

    for (int i = 0; i < numFaces - 1; ++i) {
        std::pair<int, int> link = FacesP[numFaces - 2 - i];
        parent = link.first;
        child = link.second;

        // Round the fractional vertices for the child triangle
        nb_v_in_Tri[child] = (std::round(fractionalVertices[child]) > 0.0) ? std::round(fractionalVertices[child]) : 0;
        
        // Calculate the error and propagate it to the parent triangle
        double error = fractionalVertices[child] - nb_v_in_Tri[child];
        fractionalVertices[parent] += error;
    }
    nb_v_in_Tri[parent] = (std::round(fractionalVertices[parent]) > 0.0) ? std::round(fractionalVertices[parent]) : 0;


    // Step 3: Propagate the error through the spanning tree for the feature edges
    for (int i = 0; i < numEdges - 1; ++i) {
        std::pair<int, int> link = FeaturesP[numEdges - 2 - i];
        parent = link.first;
        child = link.second;

        nb_v_in_feat_edge[child] = (std::round(fractionalEdges[child]) > 0.0) ? std::round(fractionalEdges[child]) : 0;

        double error = fractionalEdges[child] - nb_v_in_feat_edge[child];
        fractionalEdges[parent] += error;
    }
    nb_v_in_feat_edge[parent] = (std::round(fractionalEdges[parent]) > 0.0) ? std::round(fractionalEdges[parent]) : 0;

    std::cout << "end errorPropagation" << std::endl << std::endl;
}


std::map<Edge, std::set<unsigned int>>  createMapTriangleOnEdge(const MatrixXi &F){     // same function as for the subdivision tp
    std::map< Edge , std::set< unsigned int > > trianglesOnEdge;    // this will be useful to get the angle between the two triangle of an edge

    // create appropriate tools similar to subdivision tp
    for (unsigned int tIt = 0; tIt < F.rows(); ++tIt) {
        int a = F(tIt,0);
        int b = F(tIt,1);
        int c = F(tIt,2);

        Edge Eab(a, b);
        Edge Ebc(b, c);
        Edge Eca(c, a);

        trianglesOnEdge[Eab].insert(tIt);
        trianglesOnEdge[Ebc].insert(tIt);
        trianglesOnEdge[Eca].insert(tIt);
    }

    return trianglesOnEdge;
}


std::map<unsigned int, std::set<unsigned int>> createMapAdjacentVertices(const MatrixXi &F) {   // similar idea then the createMapTriangleOnEdge function
    std::map<unsigned int, std::set<unsigned int>> adjacentVertices;

    // Loop through each triangle in the mesh
    for (unsigned int tIt = 0; tIt < F.rows(); ++tIt) {
        // Get the vertices of the triangle
        int a = F(tIt, 0);
        int b = F(tIt, 1);
        int c = F(tIt, 2);

        // For each vertex in the triangle, add the other two vertices as neighbors
        adjacentVertices[a].insert(b);
        adjacentVertices[a].insert(c);

        adjacentVertices[b].insert(a);
        adjacentVertices[b].insert(c);

        adjacentVertices[c].insert(a);
        adjacentVertices[c].insert(b);
    }

    return adjacentVertices;
}



void createFeature(
        MatrixXi &feat,                         // Matrix to store the feature edges
        Eigen::VectorXi &corn,                  // Vector to store the corner vertices
        const MatrixXd &V,                      // Matrix of 3D vertex coordinates
        const MatrixXi &F,                      // Matrix of face (triangle) vertex indices
        const Eigen::VectorXi &bnd,             // Boundary vertices
        const std::map<Edge, std::set<unsigned int>> trianglesOnEdge, // Map of edges and the triangles that use them
        double threshold = 50.0) {              // Threshold angle for distinguishing corner edges

    std::cout << "in createFeature" << std::endl;

    // Temporary storage for feature edges
    std::vector<Eigen::VectorXi> temp_feat;
    Eigen::VectorXi edge(2);

    // Add the boundary edges to the feature edges list
    edge << bnd(bnd.size() - 1), bnd(0);
    temp_feat.push_back(edge); 
    for (int i = 0; i < bnd.size() - 1; ++i) {
        edge << bnd(i), bnd(i + 1); 
        temp_feat.push_back(edge); 
    }

    // Determine edges based on the angle between adjacent triangles sharing the edge
    for (const auto& [edge, tris] : trianglesOnEdge) {
        if (tris.size() == 2) {  // Only internal edges between two triangles
            auto it = tris.begin();
            int t1 = *it++;  
            int t2 = *it;    

            Eigen::RowVector3d n1 = Eigen::Vector3d(V.row(F(t1, 1)) - V.row(F(t1, 0))).cross(Eigen::Vector3d(V.row(F(t1, 2)) - V.row(F(t1, 0)))).normalized();
            Eigen::RowVector3d n2 = Eigen::Vector3d(V.row(F(t2, 1)) - V.row(F(t2, 0))).cross(Eigen::Vector3d(V.row(F(t2, 2)) - V.row(F(t2, 0)))).normalized();

            double angle = std::acos(std::clamp(n1.dot(n2), -1.0, 1.0)) * 180.0 / M_PI;

            if (angle > threshold) {
                temp_feat.push_back(Eigen::Vector2i(edge.a, edge.b));
            }
        }
    }

    // Convert the temporary feature edges list into a MatrixXi
    int rows = temp_feat.size();
    int cols = 2;
    feat.resize(rows, cols);

    for (int i = 0; i < rows; ++i) {
        feat.row(i) = temp_feat[i]; // Copy each feature edge into the output matrix
    }

    // Create a map to associate each vertex with the edges it belongs to
    std::map<int, std::vector<Eigen::Vector2i>> vertexToEdges;
    for (const auto& edge : temp_feat) {
        vertexToEdges[edge(0)].push_back(edge); 
        vertexToEdges[edge(1)].push_back(edge); 
    }

    // Determine the corner vertices (those connected to more than two edges or forming a sharp angle)
    std::vector<int> cornerList;
    for (const auto& [vertex, edges] : vertexToEdges) {
        if (edges.size() != 2) {  // Vertices connected to more than two edges are considered corners
            cornerList.push_back(vertex);
        } else if (edges.size() == 2) {
            Eigen::Vector2i edge1 = edges[0];
            Eigen::Vector2i edge2 = edges[1];

            Eigen::Vector3d v1 = V.row(edge1[0]) - V.row(edge1[1]);
            Eigen::Vector3d v2 = V.row(edge2[0]) - V.row(edge2[1]); 

            // Calculate the angle between the two edges
            double edgeAngle = std::acos(std::clamp(v1.normalized().dot(v2.normalized()), -1.0, 1.0)) * 180.0 / M_PI;
            
            // If the angle between the edges is greater than the threshold, consider the vertex a corner
            if (edgeAngle > threshold) {
                cornerList.push_back(vertex);
            }
        }
    }

    // Convert the corner list into a VectorXi
    corn.resize(cornerList.size());
    for (int i = 0; i < cornerList.size(); ++i) {
        corn(i) = cornerList[i]; 
    }

    std::cout << "out createFeature" << std::endl << std::endl;
}


void uniformeDensity(
        std::vector<float> &faceDens, 
        std::vector<float> &featEdgeDens, 
        double &Rs,      // sample rate of surfaces
        double &Rf,      // sample rate of features
        const MatrixXd &V, 
        const MatrixXd &V_, 
        const MatrixXi &F, 
        const MatrixXi &feat, // feat.clos = 2
        const Eigen::VectorXi &corn, 
        const std::map<Edge, std::set<unsigned int>> trianglesOnEdge,
        const int &budget) {

    std::cout << "in uniformeDensity" << std::endl;

    int numFaces = F.rows();
    int numFeatures = feat.rows();
    faceDens.resize(numFaces, 0.0f);
    featEdgeDens.resize(numFeatures, 0.0f);

    double totalFaceDensity = 0.0;
    double totalFeatureDensity = 0.0;
    
    // Calcul des densités pour chaque triangle
    for (int i = 0; i < numFaces; ++i) {
        // Sommets du triangle en 3D
        Eigen::RowVector3d A = V.row(F(i, 0));
        Eigen::RowVector3d B = V.row(F(i, 1));
        Eigen::RowVector3d C = V.row(F(i, 2));
        
        // Sommets du triangle en 2D
        Eigen::RowVector2d A_uv = V_.row(F(i, 0));
        Eigen::RowVector2d B_uv = V_.row(F(i, 1));
        Eigen::RowVector2d C_uv = V_.row(F(i, 2));
        
        // Aires des triangles
        double area3D = triangleArea(A, B, C);
        double area2D = triangleArea2D(A_uv, B_uv, C_uv);
        
        // Calcul de la densité proportionnelle
        faceDens[i] = (area3D / area2D);
        totalFaceDensity += area3D;  // = density[i] * area2D = area3D;
    }


    for (int i = 0; i < numFeatures; ++i){
        Edge e = Edge(feat(i,0), feat(i,1));
        std::set<unsigned int> triangles = trianglesOnEdge.find(e)->second;
        if (triangles.size() == 1){
            featEdgeDens[i] = faceDens[*triangles.begin()];
            totalFeatureDensity += featEdgeDens[i] * (V_.row(e.a) - V_.row(e.b)).norm();
        } 
        else if (triangles.size() == 2){
            auto it = triangles.begin();
            unsigned int t0 = *it;
            it++;
            unsigned int t1 = *it;

            Eigen::RowVector3d A0 = V.row(F(t0, 0));
            Eigen::RowVector3d B0 = V.row(F(t0, 1));
            Eigen::RowVector3d C0 = V.row(F(t0, 2));
            Eigen::RowVector3d A1 = V.row(F(t1, 0));
            Eigen::RowVector3d B1 = V.row(F(t1, 1));
            Eigen::RowVector3d C1 = V.row(F(t1, 2));

            double areat0 = triangleArea(A0, B0, C0);
            double areat1 = triangleArea(A1, B1, C1);

            featEdgeDens[i] = (areat0 * faceDens[t0] + areat1 * faceDens[t1]) / (areat0 + areat1);
            totalFeatureDensity += featEdgeDens[i] * (V_.row(e.a) - V_.row(e.b)).norm();
        }
    }

    // calculate Rs and Rf, here Rs = 2 * Rf^2 / sqrt(3)
    // Rs * totalFaceDensity + Rf * totalFeatureDensity + (corn.size() - budget) = 0

    double A = 2 * totalFaceDensity / sqrt(3);
    double B = totalFeatureDensity;
    double C = corn.rows() - budget;

    double discriminant = B * B - 4 * A * C;
    Rf = (-B + sqrt(discriminant)) / (2 * A);
    Rs = 2 * Rf * Rf / sqrt(3);
    
    std::cout << "out uniformeDensity" << std::endl << std::endl;
}



Eigen::RowVector3d randomBarycentric(std::mt19937 &gen) {
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    double u = dist(gen);
    double v = dist(gen);
    
    if (u + v > 1.0) {
        u = 1.0 - u;
        v = 1.0 - v;
    }
    
    double w = 1.0 - u - v;

    return Eigen::RowVector3d(u, v, w);
}


// Generate points based on density for triangles and feature edges
void initialResample(
        MatrixXd &B,
        const MatrixXd &V, 
        const MatrixXi &F, 
        const std::vector<int> &nb_v_in_Tri,
        const std::vector<int> &nb_v_in_feat_edge,
        const MatrixXi &feat, 
        const Eigen::VectorXi &corn) {

    std::cout << "in initialResample" << std::endl;

    std::vector<Eigen::RowVector2d> newPoints;  // Vector to store the generated points

    // Random number generator setup
    std::random_device rd;
    std::mt19937 gen(rd());

    // ------- Sampling on triangles -------
    for (int i = 0; i < F.rows(); i++) {
        int numPoints = nb_v_in_Tri[i];  // Number of points to generate for this triangle
        
        for (int j = 0; j < numPoints; j++) {
            Eigen::RowVector3d bary = randomBarycentric(gen);  // Generate random barycentric coordinates

            // Calculate the 3D point coordinates using barycentric interpolation
            Eigen::RowVector2d point = 
                bary[0] * V.row(F(i, 0)) + 
                bary[1] * V.row(F(i, 1)) + 
                bary[2] * V.row(F(i, 2));

            newPoints.push_back(point);  // Add the point to the list
        }
    }

    // ------- Sampling on feature edges -------
    for (int i = 0; i < feat.rows(); i++) {
        int numPoints = nb_v_in_feat_edge[i];  // Number of points to generate for this feature edge
        
        Eigen::RowVector2d A_uv = V.row(feat(i, 0));  // First vertex of the feature edge
        Eigen::RowVector2d B_uv = V.row(feat(i, 1));  // Second vertex of the feature edge

        // Generate points along this feature edge
        for (int j = 0; j < numPoints; j++) {
            std::uniform_real_distribution<double> dist(0.0, 1.0);  // Uniform distribution between 0 and 1
            double t = dist(gen);  // Random parameter for interpolation

            // Calculate the point coordinates along the edge using linear interpolation
            Eigen::RowVector2d point = (1 - t) * A_uv + t * B_uv;

            newPoints.push_back(point);  // Add the point to the list
        }
    }

    // ------- Add corners -------
    for (int i = 0; i < corn.size(); ++i) {
        int index = corn(i);  // Get the index of the corner point from `corn`
        Eigen::RowVector2d point = V.row(index);  // Retrieve the coordinates from `V`
        newPoints.push_back(point);  // Add the corner point to the list
    }

    // Convert the list of points to Eigen matrix format
    B.resize(newPoints.size(), 2);  // Resize the output matrix to fit the generated points

    for (size_t i = 0; i < newPoints.size(); i++) {
        B.row(i) = newPoints[i];  // Assign the generated points to the matrix
    }

    std::cout << "out initialResample" << std::endl << std::endl;
}



bool isPointInCircumcircle(const Eigen::Vector2d& p, const Eigen::Vector2d& a, const Eigen::Vector2d& b, const Eigen::Vector2d& c) {
    Eigen::Matrix4d M;
    M << a.x(), a.y(), a.squaredNorm(), 1,
         b.x(), b.y(), b.squaredNorm(), 1,
         c.x(), c.y(), c.squaredNorm(), 1,
         p.x(), p.y(), p.squaredNorm(), 1;
    return M.determinant() > 0;
}


void computeHandDelaunayTriangulation(const Eigen::MatrixXd& V_uv, Eigen::MatrixXi& F_out) {
    std::cout << "in computeHandDelaunayTriangulation" << std::endl;

    int N = V_uv.rows();
    std::vector<Triangle> triangles;

    // gros triangle englobant tous les points
    double minX = V_uv.col(0).minCoeff(), maxX = V_uv.col(0).maxCoeff();
    double minY = V_uv.col(1).minCoeff(), maxY = V_uv.col(1).maxCoeff();
    double dx = maxX - minX, dy = maxY - minY;
    double dmax = std::max(dx, dy);
    Eigen::Vector2d p1(minX - dmax, minY - dmax);
    Eigen::Vector2d p2(maxX + dmax, minY - dmax);
    Eigen::Vector2d p3((minX + maxX) / 2, maxY + dmax); 
    triangles.push_back({N, N + 1, N + 2});

    Eigen::MatrixXd V_ext(V_uv.rows() + 3, 2);
    V_ext << V_uv, p1.transpose(), p2.transpose(), p3.transpose();

    for (int i = 0; i < N; ++i) {
        if (i%100 == 0){
            std::cout << "i : " << i << std::endl;
        }

        std::vector<Edge_> edges;
        std::vector<Triangle> newTriangles;

        for (const auto& tri : triangles) {
            if (isPointInCircumcircle(V_ext.row(i), V_ext.row(tri.v0), V_ext.row(tri.v1), V_ext.row(tri.v2))) {
                edges.push_back({tri.v0, tri.v1});
                edges.push_back({tri.v1, tri.v2});
                edges.push_back({tri.v2, tri.v0});
            } else {
                newTriangles.push_back(tri);
            }
        }

        // Suppression des arêtes en double
        std::vector<Edge_> uniqueEdges;
        for (const auto& edge : edges) {
            bool found = false;
            for (auto it = uniqueEdges.begin(); it != uniqueEdges.end(); ++it) {
                if (*it == edge) {
                    uniqueEdges.erase(it);
                    found = true;
                    break;
                }
            }
            if (!found) uniqueEdges.push_back(edge);
        }

        for (const auto& edge : uniqueEdges) {
            newTriangles.push_back({edge.v0, edge.v1, i});
        }

        triangles = std::move(newTriangles);
    }

    // Suppression des triangles contenant les sommets du super-triangle
    std::vector<Triangle> finalTriangles;
    for (const auto& tri : triangles) {
        if (tri.v0 < N && tri.v1 < N && tri.v2 < N) {
            finalTriangles.push_back(tri);
        }
    }

    // Stocker le résultat
    F_out.resize(finalTriangles.size(), 3);
    for (size_t i = 0; i < finalTriangles.size(); ++i) {
        F_out(i, 0) = finalTriangles[i].v0;
        F_out(i, 1) = finalTriangles[i].v1;
        F_out(i, 2) = finalTriangles[i].v2;
    }

    std::cout << "out computeHandDelaunayTriangulation" << std::endl << std::endl;
}


void computeDelaunatorDelaunayTriangulation(MatrixXi& F, const MatrixXd& V, const MatrixXi &feat){
    std::cout << "in computeDelaunatorDelaunayTriangulation" << std::endl;
    if (V.cols() != 2){
        std::cout << "the numbre of columns of V is not 2 (nb of col : " << V.cols() << ")" << std::endl;
    }
    
    /* x0, y0, x1, y1, ... */
    std::vector<double> coords;

    // Remplir coords avec les éléments de V
    for (int i = 0; i < V.rows(); ++i) {
        for (int j = 0; j < V.cols(); ++j) {
            coords.push_back(V(i, j)); // Ajouter chaque coordonnée à coords
        }
    }

    //triangulation happens here
    delaunator::Delaunator d(coords);

    // 4. Réécrire les résultats dans Eigen::MatrixXi& F
    int num_triangles = d.triangles.size() / 3;
    F = MatrixXi(num_triangles, 3);

    for (int i = 0; i < num_triangles; ++i) {
        F(i, 0) = d.triangles[3 * i];     // Premier sommet du triangle
        F(i, 1) = d.triangles[3 * i + 1]; // Deuxième sommet
        F(i, 2) = d.triangles[3 * i + 2]; // Troisième sommet
    }

    std::cout << "out computeDelaunatorDelaunayTriangulation" << std::endl << std::endl;
}



DT computeCGALDelaunayTriangulation(MatrixXi& F, const MatrixXd& V, const MatrixXi &feat){
    std::cout << "in computeCGALDelaunayTriangulation" << std::endl;
    std::vector<Point> points;
    for (int i = 0; i < V.rows(); i++)
        points.push_back(Point(V(i, 0), V(i, 1)));
    
    DT dt;
    dt.insert(points.begin(), points.end());

    int num_faces = dt.number_of_faces();
    F.resize(num_faces, 3);
    
    // Étape 1 : Associer chaque vertex à un index
    std::unordered_map<DT::Vertex_handle, int> vertex_index_map;
    int index = 0;
    for (auto vit = dt.finite_vertices_begin(); vit != dt.finite_vertices_end(); ++vit) {
        vertex_index_map[vit] = index++;
    }

    // Étape 2 : Construire F en utilisant la map
    int f_idx = 0;
    for (auto fit = dt.finite_faces_begin(); fit != dt.finite_faces_end(); ++fit) {
        for (int i = 0; i < 3; ++i) {
            auto vit = fit->vertex(i);
            F(f_idx, i) = vertex_index_map[vit];  // Récupérer l'index correct
        }
        f_idx++;
    }

    std::cout << "out computeCGALDelaunayTriangulation" << std::endl << std::endl;
    return dt;
}



VD computeCGALVoronoiTessellation(const DT &dt, MatrixXd &P, MatrixXi &Fp) {
    std::cout << "in computeCGALVoronoiTessellation" << std::endl;
    // Step 1: Construct the Voronoi Diagram from Delaunay
    VD vd(dt);

    std::vector<Eigen::Vector2d> voronoi_vertices;
    std::vector<Eigen::Vector2i> voronoi_edges;
    std::map<Point_2, int> vertex_indices;
    int index = 0;

    // Extraction of vertices
    for (VD::Vertex_iterator vit = vd.vertices_begin(); vit != vd.vertices_end(); ++vit) {
        if (!vit->is_valid()) continue;  // Vérification de validité

        Point_2 p = vit->point();
        Eigen::Vector2d v(p.x(), p.y());

        vertex_indices[p] = index++;
        voronoi_vertices.push_back(v);
    }

    // Extraction of edges
    for (VD::Edge_iterator eit = vd.edges_begin(); eit != vd.edges_end(); ++eit) {
        if (!eit->has_source() || !eit->has_target()) continue;

        Point_2 src = eit->source()->point();
        Point_2 tgt = eit->target()->point();

        if (vertex_indices.find(src) != vertex_indices.end() &&
            vertex_indices.find(tgt) != vertex_indices.end()) {
            voronoi_edges.emplace_back(vertex_indices[src], vertex_indices[tgt]);
        }
    }

    // Conversion in Eigen::MatrixXd
    P.resize(voronoi_vertices.size(), 2);
    for (size_t i = 0; i < voronoi_vertices.size(); ++i) {
        P.row(i) = voronoi_vertices[i];
    }

    Fp.resize(voronoi_edges.size(), 2);
    for (size_t i = 0; i < voronoi_edges.size(); ++i) {
        Fp.row(i) = voronoi_edges[i];
    }

    std::cout << "out computeCGALVoronoiTessellation" << std::endl << std::endl;
    return vd;
}



bool key_down(igl::opengl::glfw::Viewer& viewer, unsigned char key, int modifier) {
    // std::cout << "Key pressed: " << key << std::endl;
    std::vector<unsigned char> str_list = {'2', '3', '4', '6', '7'};
    if (std::find(str_list.begin(), str_list.end(), key) != str_list.end()){
        for (int i = 0; i < viewer.data_list.size(); ++i) { // Clear all previous mesh before switching
            viewer.data_list[i].clear();
        } 
        viewer.data().line_width = 0.5;

        if (key == '1') {
            viewer.data().set_mesh(V_new_original, F_new);
            viewer.core().align_camera_center(V_new_original, F_new);
        }
        else if (key == '2') {
            viewer.data().set_mesh(V0, F0);
            viewer.core().align_camera_center(V0, F0);
        }
        else if (key == '3') {
            viewer.data().set_mesh(V_uv, F0);
            viewer.core().align_camera_center(V_uv, F0);
        }
        else if (key == '4') {
            viewer.data().set_mesh(V_new_uv, F_new);
            viewer.core().align_camera_center(V_new_uv, F_new);
        }
        else if (key == '6') {
            // viewer.data().set_mesh(V_new_uv, F_new);  // delaunay triangulation
            viewer.data().set_mesh(V_uv, F0);            // initial mesh parametrized

            // Voronoi tessellation
            viewer.append_mesh();
            int edge_data_id = viewer.selected_data_index;

            viewer.data_list[edge_data_id].line_width = 2.0;
            viewer.data_list[edge_data_id].point_size = 2;
            viewer.data_list[edge_data_id].add_points(V_new_uv, Eigen::RowVector3d(0, 0, 1)); // Blue points
            for (int i = 0; i < Fp.rows(); ++i) {
                viewer.data_list[edge_data_id].add_edges(P.row(Fp(i, 0)), P.row(Fp(i, 1)), Eigen::RowVector3d(0, 0, 1)); // Blue edges
            }
            viewer.core().align_camera_center(V_uv, F0);
        }
        else if (key == '7') {
            // viewer.data().set_mesh(V_uv, F0);  // parametrized 

            // corners point
            viewer.data().point_size = 4;
            viewer.data().line_width = 2.0;
            Eigen::MatrixXd subMatrix(corners.size(), V_uv.cols()); 
            for (int i = 0; i < corners.size(); ++i) {
                subMatrix.row(i) = V_uv.row(corners(i)); 
            }
            viewer.data().add_points(subMatrix, Eigen::RowVector3d(0, 0, 0)); 

            // for feature edges and bounderies
            for (int i = 0; i < featureEdges.rows(); ++i) {
                viewer.data().add_edges(V_uv.row(featureEdges(i,0)), V_uv.row(featureEdges(i,1)), Eigen::RowVector3d(1, 0, 0)); // red edges
            }

            viewer.core().align_camera_center(subMatrix);
        }
    }

    return false;
}



int main() {
    int budget = 5000;
    double thresholding = 45.0;     // dihedral angle thresholding
    
    // Load a mesh in OFF format
    igl::read_triangle_mesh("../../data/camelhead.off", V0, F0);
    igl::read_triangle_mesh("../../data/monkey.off", V1, F1);
    
    // Find the open boundary
    Eigen::VectorXi bnd;
    igl::boundary_loop(F0,bnd);

    // Map the boundary to a circle, preserving edge proportions
    igl::map_vertices_to_circle(V0, bnd, bnd_uv);

    // Harmonic parametrization for the internal vertices
    std::clock_t t0 = std::clock();
    igl::harmonic(V0,F0,bnd,bnd_uv,1,V_uv);
    std::clock_t t1 = std::clock();
    std::cout << "time for igl::harmonic() : " << t1 - t0 << "ms" << std::endl;

    std::map<Edge, std::set<unsigned int>> trianglesOnEdge = createMapTriangleOnEdge(F0);
    std::map<unsigned int, std::set<unsigned int>> adjacentVertices = createMapAdjacentVertices(F0);
    std::clock_t t2 = std::clock();
    std::cout << "time for trianglesOnEdge and adjacentVertices : " << t2 - t1 << "ms" << std::endl;
    
    createFeature(featureEdges, corners, V0, F0, bnd, trianglesOnEdge, thresholding);
    std::clock_t t3 = std::clock();
    std::cout << "time for createFeature() : " << t3 - t2 << "ms" << std::endl;

    arbreCouvrant(FacesPath, FeaturePath, F0, featureEdges, adjacentVertices, trianglesOnEdge); 
    std::clock_t t4 = std::clock();
    std::cout << "time for arbreCouvrant() : " << t4 - t3 << "ms" << std::endl;

    uniformeDensity(FaceDensity, featureEdgeDensity, SRs, SRf, V0, V_uv, F0, featureEdges, corners, trianglesOnEdge, budget);
    std::clock_t t5 = std::clock();
    std::cout << "time for uniformeDensity() : " << t5 - t4 << "ms" << std::endl;
    
    errorPropagation(nbNewVerticesInTriangles, nbNewVerticesInFeatureEges, SRs, SRf, FaceDensity, featureEdgeDensity, V_uv, F0, featureEdges, FacesPath, FeaturePath);
    std::clock_t t6 = std::clock();
    std::cout << "time for errorPropagation() : " << t6 - t5 << "ms" << std::endl;

    std::cout << "nbNewVerticesInTriangles : " << std::accumulate(nbNewVerticesInTriangles.begin(), nbNewVerticesInTriangles.end(), 0) << std::endl;
    std::cout << "nbNewVerticesInFeatureEges : " << std::accumulate(nbNewVerticesInFeatureEges.begin(), nbNewVerticesInFeatureEges.end(), 0) << std::endl;
    std::cout << "corners : " << corners.size() << std::endl;
    std::cout << "sum up to : " << corners.size() 
    + std::accumulate(nbNewVerticesInTriangles.begin(), nbNewVerticesInTriangles.end(), 0) 
    + std::accumulate(nbNewVerticesInFeatureEges.begin(), nbNewVerticesInFeatureEges.end(), 0) << std::endl;
    
    initialResample(V_new_uv, V_uv, F0, nbNewVerticesInTriangles, nbNewVerticesInFeatureEges, featureEdges, corners);
    std::clock_t t7 = std::clock();
    std::cout << "time for initialResample() : " << t7 - t6 << "ms" << std::endl;

    computeDelaunatorDelaunayTriangulation(F_new, V_new_uv, featureEdges);
    std::clock_t t8 = std::clock();
    std::cout << "time for computeDelaunatorDelaunayTriangulation() : " << t8 - t7 << "ms" << std::endl;

    DT dt = computeCGALDelaunayTriangulation(F_new_, V_new_uv, featureEdges);    
    std::clock_t t9 = std::clock();
    std::cout << "time for computeCGALDelaunayTriangulation() : " << t9 - t8 << "ms" << std::endl;
    
    VD vd = computeCGALVoronoiTessellation(dt, P, Fp);
    std::clock_t t10 = std::clock();
    std::cout << "time for computeCGALDelaunayTriangulation() : " << t10 - t9 << "ms" << std::endl;

    // Use harmonic solver to map V_new_uv back to the original 3D space
    // igl::harmonic(V0, F0, bnd, V_new_uv, 1, V_new_original);



    // -------------------- view mesh ---------------------- //
    std::cout<<R"(
    2 original camelhead Mesh
    3 parametrized original mesh
    4 first delaunay mesh
    6 voronoi tessellation with it's sites lying on the original mesh
    7 feature edges of the original mesh
    )";

    igl::opengl::glfw::Viewer viewer;
    viewer.callback_key_down = &key_down;
    viewer.data().set_mesh(V_new_uv, F_new);
    viewer.core().background_color = Eigen::Vector4f(1.0f, 1.0f, 1.0f, 1.0f);

    // Disable wireframe
    viewer.data().show_lines = true;

    // // Draw default checkerboard texture
    // viewer.data().show_texture = true;

    viewer.launch();

    return 0;
}